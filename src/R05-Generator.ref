*$FROM R5FW-Parser-Defs
$EXTERN Extern, Entry, Function, SpecialComment, Local, Variable, RETURN, Symbol,
  Brackets, Char, Number, Word, Call;

*$FROM LibraryEx
$EXTERN SaveFile, MapAccum, Map, Dec, Inc;

*$FROM R5FW-Plainer
$EXTERN InlineExpr;

*$FROM R5FW-Transformer
$EXTERN Transform;
*$EXTERN NO-POS

*$FROM Library
*$EXTERN True, False


/**
  <R05-Generate-ToFile (e.OutputFile) e.Tree> == пусто
*/
$ENTRY R05-Generate-ToFile {
  (e.OutputFile) e.Tree =
    <SaveFile (e.OutputFile) <R05-Generate-ToLines e.Tree>>;
}

/**
  <R05-Generate-ToLines e.Tree> == (s.CHAR*)*
*/
$ENTRY R05-Generate-ToLines {
  e.Tree
    = <R05-Generate-Aux
        <MapAccum
          generator_GenTreeItem (/* declarations */)
          <InsertConcatenators <Transform e.Tree>>
        >
      >;
}

/*
  <InsertConcatenators e.AST> == e.AST
  Заменяет результатные выражения вида <Function1 e.arg1> <Function2 e.arg2>
  на <Cat@ (<Function1 e.arg1>) <Function2 e.arg2>>
*/
InsertConcatenators {
  e.AST = (Extern (NO-POS 'Cat@')) <Map InsertConcatenators-Aux e.AST>;
}

$ENTRY InsertConcatenators-Aux {
  (Extern e.externBody) = (Extern e.externBody);

  (SpecialComment e.CommentBody) = (SpecialComment e.CommentBody);

  (Function t.SrcPos (e.Name) s.Scope e.Sentences)
    = (
        Function t.SrcPos (e.Name) s.Scope
        <Map InsertConcatenators-Sentences e.Sentences>
      );
}

$ENTRY InsertConcatenators-Sentences {
  (t.Pattern RETURN (e.Result))
    = (
        t.Pattern
        RETURN
        (<InsertConcatenators-Result e.Result>)
      );
}

InsertConcatenators-Result {
  (Call t.ScrPos1 (e.Name1) e.MoreTerms)
  e.ZeroOrMoreEVars
  (Call t.ScrPos2 (e.Name2) e.MoreTerms2)
  e.TermsTail
    , <IsEvarSequence e.ZeroOrMoreEVars> : True
    = <InsertConcatenators-Result
      (Call NO-POS ('Cat@')
            (Brackets
              (Call t.ScrPos1 (e.Name1) <InsertConcatenators-Result e.MoreTerms>)
            )
            e.ZeroOrMoreEVars
            (Call t.ScrPos2 (e.Name2) <InsertConcatenators-Result e.MoreTerms2>)
      )
      e.TermsTail
      >;

  (Call t.SrcPos (e.Name) e.MoreTerms) e.TermsTail
    = (Call t.SrcPos (e.Name) <InsertConcatenators-Result e.MoreTerms>)
      <InsertConcatenators-Result e.TermsTail>;

  (Brackets e.MoreTerms) e.TermsTail
    = (Brackets <InsertConcatenators-Result e.MoreTerms>)
      <InsertConcatenators-Result e.TermsTail>;

  t.OtherTerm e.TermsTail
    = t.OtherTerm <InsertConcatenators-Result e.TermsTail>;

  /* empty */ = /* empty */;
}

IsEvarSequence {
  e.expr = <And <Map IsEvar e.expr>>;
}

$ENTRY IsEvar {
  (Variable t.SrcPos 'e' e.Index) = True;
  e.AnyOther = False;
}

And {
  e.B False e.E = False;
  e.Trues = True;
}

R05-Generate-Aux {
  (e.Declarations) e.Definitions =
    ('/* Automatically generated file. Don\'t edit! */')
    ('#include "refal05rts.h"')
    ('#include <stdio.h>')
    ()
    ()
    e.Declarations
    ()
    e.Definitions
    ()
    ('/* End of file */')
}

$ENTRY generator_GenTreeItem {
  (e.Declarations) (Extern e.Names) =
    (e.Declarations <Map r05-generator_GenExtern e.Names>)
    /* пусто */;

  (e.Declarations) (Function t.SrcPos (e.Name) s.ScopeClass e.Body) =
    (e.Declarations <GenDeclaration s.ScopeClass e.Name>)
    <GenFunction s.ScopeClass (e.Name) e.Body>;

  (e.Declarations) (SpecialComment t.SrcPos e.Text) =
    (e.Declarations)
    ('/*')
    (<SafeSpecialComment e.Text>)
    ('*/');
}

SafeSpecialComment {
  '!' e.Comment = '!!' <SafeSpecialComment e.Comment>;
  '/*' e.Comment = '/!*' <SafeSpecialComment e.Comment>;
  '*/' e.Comment = '*!/' <SafeSpecialComment e.Comment>;
  s.Other e.Comment = s.Other <SafeSpecialComment e.Comment>;
  /* пусто */ = /* пусто */;
}

$ENTRY r05-generator_GenExtern {
  (t.SrcPos e.Name) = <GenDeclaration Entry e.Name>;
}


Scope {
  Entry = 'ENTRY'; Local = 'LOCAL';
}

GenDeclaration {
  s.ScopeClass e.Name =
    ('R05_DECLARE_' <Scope s.ScopeClass> '_FUNCTION(' <EscapeName e.Name> ')');
}

GenFunction {
  s.ScopeClass (e.Name) /* пусто */ =
    ('R05_DEFINE_' <Scope s.ScopeClass> '_ENUM(' <DefName e.Name> ')')
    ();

  s.ScopeClass (e.Name) e.Sentences =
    ('R05_DEFINE_' <Scope s.ScopeClass> '_FUNCTION(' <DefName e.Name> ') {')
    ('  r05_this_is_generated_function(state);')
    <Map generator_GenSentence <AddFailCommand e.Sentences>>
    ('}')
    ();
}

DefName {
  e.Name = <EscapeName e.Name> ', "' e.Name '"';
}

/*
  Разрешим знак $ для функций Stop$$ и Imp$$ на всякий случай.
  Декорирование было выбрано именно таким, чтобы избежать двух прочерков
  подряд в декорированном имени.
*/
EscapeName {
  '_' e.Name = 'u_' <EscapeName e.Name>;
  '-' e.Name = 'm_' <EscapeName e.Name>;
  '$' e.Name = 'd_' <EscapeName e.Name>;
  '@' e.Name = 'a_' <EscapeName e.Name>;
  s.Other e.Name = s.Other <EscapeName e.Name>;
  /* пусто */ = /* пусто */;
}

*$ENUM ReturnRecognitionImpossible

AddFailCommand {
  /*
    если последнее предложение имеет вид
    e.X = ...;, в конце не генерится вызов
    r05_recognition_impossible()
  */
  e.Sentences (((Variable t.SrcPos 'e' e.Index)) RETURN (e.Result)) =
    e.Sentences (((Variable t.SrcPos 'e' e.Index)) RETURN (e.Result));

  e.Sentences = e.Sentences ReturnRecognitionImpossible;
}

$ENTRY generator_GenSentence {
  ((e.Pattern) RETURN (e.Result)) =
    ()
    ('  do {')
    <SkipIndentAccum
      <MapAccum
        generator_GenCommand
        ('    ' /* отступ */)
        <CompileSentence (e.Pattern) (e.Result)>
      >
    >
    ('  } while (0);');

  ReturnRecognitionImpossible =
    ()
    ('  r05_recognition_impossible(state);');
}

SkipIndentAccum {
  /* отступ должен остаться тем же */
  ('    ') e.Generated = e.Generated;
}

RangeVar-B { s.BracketNumber = 'bb[' <Symb s.BracketNumber> ']' }
RangeVar-E { s.BracketNumber = 'be[' <Symb s.BracketNumber> ']' }

RangeVars {
  s.BracketNumber =
    <RangeVar-B s.BracketNumber> ', ' <RangeVar-E s.BracketNumber>;
}

RangeVarsPtr {
  s.BracketNumber = 'bb+' <Symb s.BracketNumber> ', be+' <Symb s.BracketNumber>;
}

SafeComment {
  e.Comment-B '/*' e.Comment-E =
    <SafeComment e.Comment-B '/\' \'*' e.Comment-E>;

  e.Comment-B '*/' e.Comment-E =
    <SafeComment e.Comment-B '*\' \'/' e.Comment-E>;

  e.Comment = e.Comment;
}

$ENTRY generator_GenCommand {
  (e.Indent)
  (CmdOpenedE-Start s.BracketNumber 'e' e.Index) =
    (e.Indent '  ')
    <CmdOpenedE-Start (e.Indent) s.BracketNumber 'e' e.Index>;

  (e.Indent '  ')
  (CmdOpenedE-End s.BracketNumber 'e' e.Index) =
    (e.Indent)
    <CmdOpenedE-End (e.Indent) s.BracketNumber 'e' e.Index>;

  (e.Indent) (s.Command e.Args) =
    (e.Indent) <Mu s.Command (e.Indent) e.Args>;
}

CmdComment {
  (e.Indent) e.Text = (e.Indent '/* ' <SafeComment e.Text> ' */');
}

CmdDeclareVar {
  (e.Indent) s.Usings 'e' e.Index =
    (e.Indent 'struct r05_node *' <EVar-B s.Usings 'e' e.Index> ';')
    (e.Indent 'struct r05_node *' <EVar-E s.Usings 'e' e.Index> ';');

  (e.Indent) s.Usings s.Mode e.Index =
    (e.Indent 'struct r05_node *' <Var s.Usings s.Mode e.Index> ';');
}

CmdRangeArray {
  (e.Indent) s.Size =
    (e.Indent 'struct r05_node *bb[' <Symb s.Size> '] = { 0 };')
    (e.Indent 'struct r05_node *be[' <Symb s.Size> '] = { 0 };');
}

CmdInitB0 {
  (e.Indent) =
    (
      e.Indent
      'r05_prepare_argument(' <RangeVarsPtr 0>
      ', state->arg_begin, state->arg_end);'
    );
}

CmdMatch {
  (e.Indent) s.Direction s.BracketNumber s.Type e.Value =
    (e.Indent
      'if (! r05_' <MatchFunc s.Type e.Value> '_' <StrFromDirection s.Direction>
      '(' <MatchArgs s.Type e.Value> ', ' <RangeVarsPtr s.BracketNumber>
      ', state))'
    )
    (e.Indent '  continue;');
}

MatchFunc {
  Symbol s.Type e.Value = <SymbolFunc s.Type>;
  Brackets s.InnerNum = 'brackets';
  Repeated s.Usings 'e' e.Index = 'repeated_evar';
  Repeated s.Usings s.Mode e.Index = 'repeated_stvar';
  Variable 's' e.Index = 'svar';
  Variable 't' e.Index = 'tvar';
}

SymbolFunc {
  Char = 'char';
  Number = 'number';
  Word = 'function';
}

StrFromDirection {
  AlgLeft = 'left'; AlgRight = 'right';
}

MatchArgs {
  Symbol s.Type e.Value = <SymbolTextRep s.Type e.Value>;

  Brackets s.InnerNum = <RangeVarsPtr s.InnerNum>;

  Repeated s.Usings s.Mode e.Index =
    <VarPtr s.Usings s.Mode e.Index> ', ' <Var <Dec s.Usings> s.Mode e.Index>;

  Variable s.Mode e.Index = <VarPtr 1 s.Mode e.Index>;
}

SymbolTextRep {
  Char s.Char = '\'' <r05-generator_EscapeChar s.Char> '\'';
  Number s.Number = <Symb s.Number> 'UL';
  Word e.Name = '&r05f_' <EscapeName e.Name>;
}

CmdEmpty {
  (e.Indent) s.BracketNumber =
    (e.Indent 'if (! r05_empty_seq(' <RangeVars s.BracketNumber> '))')
    (e.Indent '  continue;');
}

CmdClosedE {
  (e.Indent) s.BracketNumber 'e' e.Index =
    (e.Indent <EVar-B 1 'e' e.Index> ' = ' <RangeVar-B s.BracketNumber> ';')
    (e.Indent <EVar-E 1 'e' e.Index> ' = ' <RangeVar-E s.BracketNumber> ';');
}

CmdOpenedE-Start {
  (e.Indent) s.BracketNumber 'e' e.Index =
    (e.Indent <EVar-B 1 'e' e.Index> ' = 0;')
    (e.Indent <EVar-E 1 'e' e.Index> ' = 0;')
    (e.Indent 'r05_start_e_loop(state);')
    (e.Indent 'do {');
}

CmdOpenedE-End {
  (e.Indent) s.BracketNumber 'e' e.Index =
    (e.Indent
      '} while (r05_open_evar_advance('
      <VarPtr 1 'e' e.Index> ', ' <RangeVarsPtr s.BracketNumber>
      ', state));'
    )
    (e.Indent 'r05_stop_e_loop(state);');
}

CmdSave {
  (e.Indent) s.Old s.New =
    (e.Indent <RangeVar-B s.New> ' = ' <RangeVar-B s.Old> ';')
    (e.Indent <RangeVar-E s.New> ' = ' <RangeVar-E s.Old> ';');
}

CmdEmptyResult {
  (e.Indent) = () (e.Indent 'r05_reset_allocator(state);');
}

CmdResultArray {
  (e.Indent) s.Size =
    (e.Indent 'struct r05_node *n[' <Symb s.Size> '] = { 0 };');
}

CmdAllocateElem {
  (e.Indent) s.ElementType e.Info =
    (e.Indent 'r05_alloc_' <Mu s.ElementType e.Info>);
}

ElSymbol {
  s.Type e.Value =
    <SymbolFunc s.Type> '(' <SymbolTextRep s.Type e.Value> ', state);';
}

ElString {
  s.Len e.String =
    'chars("' <EscapeString e.String> '", ' <Symb s.Len> ', state);';
}

ElOpenBracket { s.Pos = 'open_bracket(' <ElemPtr s.Pos> ', state);' }
ElCloseBracket { s.Pos = 'close_bracket(' <ElemPtr s.Pos> ', state);' }
ElOpenCall { s.Pos = 'open_call(' <ElemPtr s.Pos> ', state);' }
ElCloseCall { s.Pos = 'close_call(' <ElemPtr s.Pos> ', state);' }

ElSavePos { s.Pos = 'insert_pos(' <ElemPtr s.Pos> ', state);' }

ElVariable { s.Mode e.Index = s.Mode 'var(' <Var 1 s.Mode e.Index> ', state);' }

CmdLinkBrackets {
  (e.Indent) s.Left s.Right =
    (e.Indent 'r05_link_brackets(' <Elem s.Left> ', ' <Elem s.Right> ');');
}

/* Работа с А-термами */

CmdAtermArray {
  (e.Indent) s.Size =
    (e.Indent 'struct r05_aterm *aterms[' <Symb s.Size> '] = { 0 };');
}

CmdAllocAterm {
  (e.Indent) s.OpenCallElemNumber s.CloseCallElemNumber s.AtermNumber
    = (
        e.Indent
        <Aterm s.AtermNumber> ' = '
        'r05_alloc_aterm('
        <Elem s.OpenCallElemNumber> ', '
        <Elem s.CloseCallElemNumber> ', '
        'state);'
      );
}

/* Аргумент внешней функции r05_aterm *aterm сохраняется в aterms[0],
 * так как он потом перезаписывается */
CmdSaveReusedAterm {
  (e.Indent) = (e.Indent 'aterms[0] = aterm;')
}

CmdReuseAterm {
  (e.Indent) s.OpenCallElemNumber s.CloseCallElemNumber
      = (
          e.Indent
          'r05_reuse_aterm('
          <Elem s.OpenCallElemNumber> ', '
          <Elem s.CloseCallElemNumber> ', '
          'aterm, state);'
        )
}

/* Аргумент функции aterm используется как позиция вставки */
CmdInsertAtermList {
  (e.Indent) s.AtermNumber
    = (
        e.Indent
        'aterm = r05_insert_aterm_list(aterm, ' <Aterm s.AtermNumber>');'
      );
}

CmdLinkAtermWithParent {
  (e.Indent) s.ChildAtermNumber 'x'
    = (
        e.Indent
        'r05_link_aterm_tree('<Aterm s.ChildAtermNumber>', parent);'
      );
  (e.Indent) s.ChildAtermNumber s.ParentAtermNumber
    = (
        e.Indent
        'r05_link_aterm_tree(' <Aterm s.ChildAtermNumber>
        ', ' <Aterm s.ParentAtermNumber> ');'
      );
}

CmdIncParentAtermCounter {
  (e.Indent) 'x' 1 = /* пусто */;
  (e.Indent) 'x' s.Value
    = (
        e.Indent
        'if (parent != NULL)'
      )
      (
        e.Indent '  '
        'atomic_fetch_add(&(parent->child_aterms), ' <Symb <Dec s.Value>> ');'
      );
  (e.Indent) s.ParentAtermNumber s.Value
    = (
        e.Indent
        'atomic_fetch_add('
        '&(' <Aterm s.ParentAtermNumber> '->child_aterms), '
        <Symb s.Value> ');'
      );
}

CmdDecParentAtermCounter {
  (e.Indent)
    = (e.Indent 'int old_counter = 0;')
      (e.Indent 'if (aterm->parent != NULL)')
      (
        e.Indent '  '
        'old_counter = atomic_fetch_sub(&(aterm->parent->child_aterms), 1);'
        '\n printf("old counter %d parent %p\\n", old_counter, aterm->parent);'
      )
      (e.Indent 'if (old_counter == 1)')
      (e.Indent '  r05_enqueue_aterm(aterm->parent, state);');
}

CmdSaveParentAterm {
  (e.Indent) = (e.Indent 'struct r05_aterm *parent = aterm->parent;');
}

CmdEnqueueAtermArray {
  (e.Indent) s.AtermNumber
    = (e.Indent 'r05_enqueue_aterm(' <Aterm s.AtermNumber> ', state);');
}

CmdEnqueueAtermReused {
  (e.Indent) = (e.Indent 'r05_enqueue_aterm(aterm, state);')
}

CmdInsertVar {
  (e.Indent) s.Pos s.Usings s.Mode e.Index =
    (e.Indent
      'r05_splice_' s.Mode 'var'
      '(' <Elem s.Pos> ', ' <Var s.Usings s.Mode e.Index> ');'
    );
}

CmdSpliceFreelist {
  (e.Indent)
    = (e.Indent 'r05_splice_from_freelist(state->arg_begin, state);')
      (
        e.Indent
        'r05_splice_to_freelist(state->arg_begin, state->arg_end, state);'
      );
}

CmdAtermCategoryComplete {
  (e.Indent) = (e.Indent 'r05_aterm_category_complete(aterm);');
}

CmdReturn {
  (e.Indent) = (e.Indent 'return;');
}

EscapeString {
  e.String = <Map r05-generator_EscapeChar e.String>;
}

$ENTRY r05-generator_EscapeChar {
  '\n' = '\\n';
  '\t' = '\\t';
  '\r' = '\\r';
  '\'' = '\\\'';
  '\"' = '\\\"';
  '\\' = '\\\\';

  s.Other = <EscapeChar-Aux s.Other <Ord s.Other>>;
}

EscapeChar-Aux {
  s.Other s.Code =
    <EscapeChar-SwCompare
      s.Other <Compare 31 s.Code> <Compare s.Code 128> s.Code
    >;
}

EscapeChar-SwCompare {
  s.Other '-' '-' s.Code = s.Other;

  s.Other s.Compare1 s.Compare2 s.Code =
    '\\'
    <Symb <Div s.Code 64>>
    <Symb <Mod <Div s.Code 8> 8>>
    <Symb <Mod s.Code 8>>;
}

Var {
  s.Usings 'e' e.Index =
    <EVar-B s.Usings 'e' e.Index> ', ' <EVar-E s.Usings 'e' e.Index>;

  s.Usings s.Mode e.Index = s.Mode <EscapeVar e.Index> '_' <Symb s.Usings>;
}

VarPtr {
  s.Usings 'e' e.Index =
    '&' <EVar-B s.Usings 'e' e.Index> ', &' <EVar-E s.Usings 'e' e.Index>;

  s.Usings s.Mode e.Index = '&' s.Mode <EscapeVar e.Index> '_' <Symb s.Usings>;
}

EVar-B { s.Usings 'e' e.Index = 'e' <EscapeVar e.Index> '_b_' <Symb s.Usings> }
EVar-E { s.Usings 'e' e.Index = 'e' <EscapeVar e.Index> '_e_' <Symb s.Usings> }

Elem { s.Number = 'n[' <Symb s.Number> ']' }
ElemPtr { s.Number = 'n+' <Symb s.Number> }

Aterm { s.Number = 'aterms[' <Symb s.Number> ']'}

/*
  Декорирование отличается от декорирования имён функций, поскольку мы хотим
  избежать двух прочерков подряд в именах переменных.
*/
EscapeVar {
  e.Name = <EscapeVar-Dash <EscapeVar-Underline e.Name>>;
}

EscapeVar-Underline {
  e.Name-B '_' e.Name-E = e.Name-B '_u' <EscapeVar-Underline e.Name-E>;
  e.Name = e.Name;
}

EscapeVar-Dash {
  e.Name-B '-' e.Name-E = e.Name-B '_m' <EscapeVar-Dash e.Name-E>;
  e.Name = e.Name;
}


*===============================================================================
* Генерация абстрактного кода для предложения
*===============================================================================

CompileSentence {
  (e.Pattern) (e.Result) =
    <CompileSentence-Aux <GenPattern e.Pattern> e.Result>;
}

CompileSentence-Aux {
  s.NumRanges (e.PatternVars) (e.PatternCommands) e.Result =
    <ComposeSentenceCommands
      s.NumRanges (e.PatternVars) (e.PatternCommands)
      <GenResult (e.PatternVars) e.Result>
    >;
}

/*
  e.Vars ::= (s.Count s.Mode e.Index)*
*/

*===============================================================================
* Генерация образца
*===============================================================================

* Направление распознавания
*$ENUM AlgLeft, AlgRight

/*
Команды распознавания
  Символы, скобки, повторные переменные и s-, t-переменные:
    (CmdMatch s.Direction s.BracketNum s.MatchType e.MatchValue)

    s.Direction ::= AlgLeft | AlgRight

    s.MatchType e.MatchValue ::=
        Symbol Char s.Char
      | Symbol Number s.Number
      | Symbol Word t.SrcPos? e.Name
      | Brackets s.InnerNum
      | Repeated s.Usings s.Mode e.Index
      | Variable t.SrcPos s.Mode e.Index

  Пустые скобки:
    (CmdEmpty s.BracketNum),

  Открытые e-переменные до обработки:
    (CmdOpenedE s.BracketNum 'e' e.Index)

  Открытые e-переменные после обработки:
    (CmdOpenedE-Start s.BracketNum 'e' e.Index)
    (CmdOpenedE-End s.BracketNum 'e' e.Index)

  Закрытые e-переменные:
    (CmdClosedE s.BracketNum 'e' e.Index)

  Команды сохранения скобок:
    (CmdSave s.OldNumber e.NewNumber)

  Комментарий, вносимый в исходный код:
    (CmdComment e.Text)
*/
*$ENUM Repeated

*$ENUM CmdOpenedE

GenPattern {
  e.Pattern =
    <DoGenPattern
      1 (0 e.Pattern) (/* vars */)
      (
        (CmdComment <InlineExpr e.Pattern>)
        /* commands */
      )
    >;
}

DoGenPattern {
  /* Распознавание литералов (символьных, целочисленных, имён) */
  s.NumRanges e.Ranges-B (s.Num (Symbol s.Type e.Value) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgLeft s.Num Symbol s.Type e.Value))
    >;

  s.NumRanges e.Ranges-B (s.Num e.Range (Symbol s.Type e.Value)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgRight s.Num Symbol s.Type e.Value))
    >;

  /* Распознавание скобок */
  s.NumRanges e.Ranges-B
  (s.Num (Brackets e.SubRange) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.NumRanges>
      e.Ranges-B (s.NumRanges e.SubRange) (s.Num e.Range) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgLeft s.Num Brackets s.NumRanges))
    >;

  s.NumRanges e.Ranges-B
  (s.Num e.Range (Brackets e.SubRange))
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.NumRanges>
      e.Ranges-B (s.Num e.Range) (s.NumRanges e.SubRange) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgRight s.Num Brackets s.NumRanges))
    >;

  /* Пустой диапазон */
  s.NumRanges e.Ranges-B (s.Num /* пусто */) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B e.Ranges-E
      (e.Vars) (e.Commands (CmdEmpty s.Num))
    >;

  /* Распознавание переменных */
  s.NumRanges
  e.Ranges-B (s.Num (Variable t.SrcPos s.Mode e.Index) e.Range) e.Ranges-E
  (e.Vars-B (s.Count s.Mode e.Index) e.Vars-E) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars-B (<Inc s.Count> s.Mode e.Index) e.Vars-E)
      (e.Commands (CmdMatch AlgLeft s.Num Repeated <Inc s.Count> s.Mode e.Index))
    >;

  s.NumRanges
  e.Ranges-B (s.Num e.Range (Variable t.SrcPos s.Mode e.Index)) e.Ranges-E
  (e.Vars-B (s.Count s.Mode e.Index) e.Vars-E) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars-B (<Inc s.Count> s.Mode e.Index) e.Vars-E)
      (e.Commands (CmdMatch AlgRight s.Num Repeated <Inc s.Count> s.Mode e.Index))
    >;

  /* Диапазон с закрытой переменной */
  s.NumRanges e.Ranges-B (s.Num (Variable t.SrcPos 'e' e.Index)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B e.Ranges-E
      (e.Vars (1 'e' e.Index))
      (e.Commands (CmdClosedE s.Num 'e' e.Index))
    >;

  s.NumRanges
  e.Ranges-B (s.Num (Variable t.SrcPos 's' e.Index) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 's' e.Index))
      (e.Commands (CmdMatch AlgLeft s.Num Variable 's' e.Index))
    >;

  s.NumRanges
  e.Ranges-B (s.Num (Variable t.SrcPos 't' e.Index) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 't' e.Index))
      (e.Commands (CmdMatch AlgLeft s.Num Variable 't' e.Index))
    >;

  s.NumRanges
  e.Ranges-B (s.Num e.Range (Variable t.SrcPos 's' e.Index)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 's' e.Index))
      (e.Commands (CmdMatch AlgRight s.Num Variable 's' e.Index))
    >;

  s.NumRanges
  e.Ranges-B (s.Num e.Range (Variable t.SrcPos 't' e.Index)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 't' e.Index))
      (e.Commands (CmdMatch AlgRight s.Num Variable 't' e.Index))
    >;

  s.NumRanges
  e.Ranges-B (s.Num (Variable t.SrcPos 'e' e.Index) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <SaveRanges
        s.NumRanges (/* scanned */) e.Ranges-B (s.Num e.Range) e.Ranges-E
        (e.Vars (1 'e' e.Index))
        (e.Commands (CmdOpenedE s.Num 'e' e.Index))
      >
    >;

  /* Завершение разбора. */
  s.NumRanges /* пусто */ (e.Vars) (e.Commands) =
    s.NumRanges (e.Vars) (e.Commands);
}

SaveRanges {
  s.NumRanges (e.ScannedRanges) (s.Num e.Range) e.Ranges
  (e.Vars) (e.Commands) =
    <SaveRanges
      <Inc s.NumRanges> (e.ScannedRanges (s.NumRanges e.Range)) e.Ranges
      (e.Vars) (e.Commands (CmdSave s.Num s.NumRanges))
    >;

  s.NumRanges (e.ScannedRanges) /* пусто */ (e.Vars) (e.Commands) =
    s.NumRanges e.ScannedRanges (e.Vars) (e.Commands);
}

*===============================================================================
* Генерация результата
*===============================================================================

GenResult {
  (e.PatternVars) e.Result =
    <DoGenResult
      (e.PatternVars)
      (/* alloc commands */)
      (/* other commands */)
      (/* nested list */)
      (/* children list */)
      0 /* счётчик новых элементов */
      0 /* счетчик количества вызовов, увеличивается на закрывающей скобке */
      0 /* счетчик глубины вызова */
      e.Result
    >;
}

* Основные команды работы с образцом
*  (CmdAllocateElem s.Number s.ElType e.Info)
*  (CmdLinkBrackets s.Left s.Right)
*  (CmdReuseAterm s.OpenCounter s.Counter)
*  (CmdAllocAterm s.OpenCounter s.Counter s.CallCounter)
*  (CmdInsertAtermList s.CallCounter)
*  (CmdInsertVar s.Pos s.Usings s.Mode e.Index)


/*
  Порядок выполнения команд.
  1. Все выделения памяти (в порядке перечисления)
  2. Связывание крулых скобок (в обратном порядке)
  3. Построение результата (в порядке перечисления)
  4. Связывание А-термов в список и в дерево (в порядке перечисления)
*/

*$ENUM TkString, TkCloseBracket, TkCloseCall

DesugarName {
  '%' = 'Mod';
  '*' = 'Mul';
  '+' = 'Add';
  '-' = 'Sub';
  '/' = 'Div';
  '?' = 'Residue';

  e.Name = e.Name;
}

DoGenResult {
  /* Оптимизация для распределения последовательности char’ов */
  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Symbol Char s.Char1) (Symbol Char s.Char2) e.Result =
    <DoGenResult
      (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      (TkString 2 s.Char1 s.Char2) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Symbol Char s.Value) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElSymbol Char s.Value))
      (e.Commands)
      (e.NestedList)
      (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (TkString s.Len e.String) (Symbol Char s.Char) e.Result =
    <DoGenResult
      (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      (TkString <Inc s.Len> e.String s.Char) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (TkString s.Len e.String) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElString s.Len e.String))
      (e.Commands)
      (e.NestedList)
      (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      e.Result
    >;

  /* Создаём литералы */
  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Symbol s.Type e.Value) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElSymbol s.Type e.Value))
      (e.Commands)
      (e.NestedList)
      (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      e.Result
    >;

  /*
    Обработка открывающих скобок всех типов осуществляется похоже.
  */
  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Brackets e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElOpenBracket s.Counter))
      (e.Commands)
      (e.NestedList)
      (e.ChildrenList)
      <Inc s.Counter> s.CallCounter s.NestedCounter
      e.InBrackets (TkCloseBracket s.Counter) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Call t.SrcPos (e.Name) e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElOpenCall s.Counter))
      (e.Commands)
      (e.NestedList)
      (e.ChildrenList)
      <Inc s.Counter> s.CallCounter <Inc s.NestedCounter>
      (Symbol Word <DesugarName e.Name>)
      e.InBrackets
      (TkCloseCall s.Counter s.NestedCounter)
      e.Result
    >;

  /*
    Закрывающие скобки надо обрабатывать особым образом.
    Круглые скобки и АТД — слинковать, угловые — добавить в стек.
  */
  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (TkCloseBracket s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElCloseBracket s.Counter))
      (
        (CmdLinkBrackets s.OpenCounter s.Counter)
        e.Commands
      )
      (e.NestedList)
      (e.ChildrenList)
      <Inc s.Counter> s.CallCounter s.NestedCounter
      e.Result
    >;

  /* Первый вызов - переиспользуем А-терм текущей функции */
  (e.Vars) (e.AllocCommands) (e.Commands)
  (/* пусто, так как первый вызов*/) (/* пусто, первый вызов */)
  s.Counter 0 /* s.CallCounter */ s.NestedCounter
  (TkCloseCall s.OpenCounter s.ThisNestedCounter)
  e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElCloseCall s.Counter))
      (
        /* порядок изменен на прямой, так как вставка происходит тоже
         * в прямом порядке */
        e.Commands
        /* Вставлять переиспользованный А-терм в список не нужно - он уже там */
        (CmdReuseAterm s.OpenCounter s.Counter)
      )
      <AppendChildCounter
        (/* nested list */) (/* children list */) s.NestedCounter 0
      >
      <Inc s.Counter> 1 /* s.CallCounter */ <Dec s.NestedCounter>
      e.Result
    >;

  /* Не первый вызов - создаем новый А-терм и вставляем его в список */
  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (TkCloseCall s.OpenCounter s.ThisNestedCounter)
  e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElCloseCall s.Counter))
      (
        /* порядок изменен на прямой, так как вставка происходит тоже
         * в прямом порядке */
        e.Commands
        (CmdAllocAterm s.OpenCounter s.Counter s.CallCounter)
        (CmdInsertAtermList s.CallCounter)
      )
      <AppendChildCounter
        (e.NestedList) (e.ChildrenList) s.NestedCounter s.CallCounter
      >
      <Inc s.Counter> <Inc s.CallCounter> <Dec s.NestedCounter>
      e.Result
    >;

  /* Оптимизация: частный случай для s-переменных, их проще всегда копировать */
  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Variable t.SrcPos 's' e.Index) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElVariable 's' e.Index))
      (e.Commands)
      (e.NestedList)
      (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      e.Result
    >;

  /* Переменная есть в образце — переносим, позиция подготовлена */
  (e.Vars-B (s.Usings s.Mode e.Index) e.Vars-E)
  (e.AllocCommands (CmdAllocateElem ElSavePos s.InsertPos))
  (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Variable t.SrcPos s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars-B <DecUsings s.Usings s.Mode e.Index> e.Vars-E)
      (e.AllocCommands (CmdAllocateElem ElSavePos s.InsertPos))
      /* вставляем в конец списка команд */
      (
        e.Commands
        (CmdInsertVar s.InsertPos s.Usings s.Mode e.Index)
      )
      (e.NestedList)
      (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      e.Result
    >;

  /* Переменная есть в образце — переносим, позиция не подготовлена */
  (e.Vars-B (s.Usings s.Mode e.Index) e.Vars-E)
  (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Variable t.SrcPos s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars-B <DecUsings s.Usings s.Mode e.Index> e.Vars-E)
      (e.AllocCommands (CmdAllocateElem ElSavePos s.Counter))
      /* вставляем в конец списка команд */
      (
        e.Commands
        (CmdInsertVar s.Counter s.Usings s.Mode e.Index)
      )
      (e.NestedList)
      (e.ChildrenList)
      <Inc s.Counter> s.CallCounter s.NestedCounter
      e.Result
    >;

  /* Переменной нет в образце — копируем */
  (e.Vars) (e.AllocCommands) (e.Commands) (e.NestedList) (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
  (Variable t.SrcPos s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElVariable s.Mode e.Index))
      (e.Commands)
      (e.NestedList)
      (e.ChildrenList)
      s.Counter s.CallCounter s.NestedCounter
      e.Result
    >;

  /* Завершение просмотра */
  (e.UnusedVars) (e.AllocCommands) (e.Commands)
  (/* если не было вызовов вообще */)
  (e.ChildrenList)
  s.Counter s.CallCounter s.NestedCounter
    = s.Counter s.CallCounter (e.UnusedVars)
      (
        e.AllocCommands
        e.Commands
      )
      (/* ChildrenList */);

  (e.UnusedVars) (e.AllocCommands) (e.Commands)
    (e.NestedList)
    (e.ChildrenList)
    s.Counter s.CallCounter s.NestedCounter
      = s.Counter s.CallCounter (e.UnusedVars)
        (
          e.AllocCommands
          e.Commands
        )
        /* 'x' - вместо номера вызова, родительского для текущей функции */
        <Second <AppendChildCounter (e.NestedList) (e.ChildrenList) 0 'x'>>;
}

Second {
  (e.First) (e.Second) = (e.Second)
}

AppendChildCounter {
  /* Если остались на том же уровне вложенности, то нужно добавить
     номер вызова в список дочерних вызовов */
  (e.NestedListBegin  (s.CurrentNestedCounter (e.ChildrenCallCounters)))
  (e.ChildrenList) s.CurrentNestedCounter s.CurrentCallCounter
    = (
        e.NestedListBegin
        (s.CurrentNestedCounter (e.ChildrenCallCounters s.CurrentCallCounter))
      )
      (e.ChildrenList);

   /* Если уровень вложенности уменьшился, то формируем в ChildrenList
      терм со списком дочерних вызовов для текущего вызова, а текущий вызов
      все также добавляем в свой уровень вложенности в NestedList*/

   /* Это случай, когда А-термы такой же вложенности уже были */
  (
    e.NestedListBegin
    (s.CurrentNestedCounter (e.PreviousChildrenCallCounters))
    (s.NestedCounter (e.ChildrenCallCounters))
  )
  (e.ChildrenList) s.CurrentNestedCounter s.CurrentCallCounter
    , <Inc s.CurrentNestedCounter> : s.NestedCounter
    = (
        e.NestedListBegin
        (
          s.CurrentNestedCounter
          (e.PreviousChildrenCallCounters s.CurrentCallCounter)
        )
      )
      (e.ChildrenList (s.CurrentCallCounter (e.ChildrenCallCounters)));

  /* Это случай, когда не было А-термов такой же вложенности,
     тогда формируется новый терм в NestedList для них */
  (
    e.NestedListBegin
    (s.NestedCounter (e.ChildrenCallCounters))
  )
  (e.ChildrenList) s.CurrentNestedCounter s.CurrentCallCounter
    , <Inc s.CurrentNestedCounter> : s.NestedCounter
    = (
        e.NestedListBegin
        (
          s.CurrentNestedCounter
          (s.CurrentCallCounter)
        )
      )
      (e.ChildrenList (s.CurrentCallCounter (e.ChildrenCallCounters)));

  /* Если уровень вложенности увеличился, или предыдущих уровней вложенности
     не было, то создается новый терм в NestedList*/
  (e.NestedList) (e.ChildrenList) s.CurrentNestedCounter s.CurrentCallCounter
    = (
        e.NestedList
        (s.CurrentNestedCounter (s.CurrentCallCounter))
      )
      (e.ChildrenList);

}

/* <MakeLinkChildAtermCommand e.ChildrenList> == e.Commands (e.Parents) */
MakeLinkChildAtermCommand {
  /* частный случай, когда был переиспользован А-терм вызвавшей функции
     и ничего свзяывать не надо */
  ('x' (0)) 1 (/* Parents */) = (/* Parents */);
  (s.ParentCallCounter (e.ChildrenCallCounters)) e.ChildrenListTail
  s.CallCounter (e.Parents)
    = <MakeLinkChildAtermCommand-Aux
        (/* link commands */) (e.ChildrenCallCounters) s.ParentCallCounter 0
      >
      <MakeLinkChildAtermCommand
        e.ChildrenListTail s.CallCounter (e.Parents s.ParentCallCounter)
      >;
  /* пусто */ s.CallCounter (e.Parents) = (e.Parents);
}

MakeLinkChildAtermCommand-Aux {
  (e.LinkCommands) (s.ChildCounter e.ChildrenCountersTail)
  s.ParentCounter s.LinkedCounter
    = <MakeLinkChildAtermCommand-Aux
      (
        e.LinkCommands
        (CmdLinkAtermWithParent s.ChildCounter s.ParentCounter)
      )
      (e.ChildrenCountersTail)
      s.ParentCounter
      <Inc s.LinkedCounter>
      >;
  (e.LinkCommands) (/* empty */) s.ParentCounter s.LinkedCounter
    = e.LinkCommands
      (CmdIncParentAtermCounter s.ParentCounter s.LinkedCounter);
}


/* В очередь добавляются все А-термы, у которых нет дочерних, то есть те,
   которых нет в списке e.Parents */
MakeEnqueueAtermsCommand {
  /* Частный случай, когда не создавалось массива А-термов */
  e.Parents 1 = (CmdEnqueueAtermReused);
  e.Parents s.CallCounter
    = <MakeEnqueueAtermsCommand-Aux e.Parents 0 s.CallCounter>;
}

MakeEnqueueAtermsCommand-Aux {
  e.Parents s.CallCounter s.CallCounter = /* пусто */;
  e.Parents-B s.CurrentCounter e.Parents-E s.CurrentCounter s.CallCounter
    = <MakeEnqueueAtermsCommand-Aux
        e.Parents-B e.Parents-E <Inc s.CurrentCounter> s.CallCounter
      >;
  e.Parents s.CurrentCounter s.CallCounter
    = (CmdEnqueueAtermArray s.CurrentCounter)
      <MakeEnqueueAtermsCommand-Aux
        e.Parents <Inc s.CurrentCounter> s.CallCounter
      >;
}

DecUsings {
  1 s.Mode e.Index = /* пусто */;
  s.Usings s.Mode e.Index = (<Dec s.Usings> s.Mode e.Index);
}


ComposeSentenceCommands {
  s.NumRanges (e.PatternVars) (e.PatternCommands) s.ResultCounter s.CallCounter
  (e.UnusedVars) (e.ResultCommands) (e.ChildrenList)
    = <ComposeSentenceCommands-Aux
        s.NumRanges s.ResultCounter s.CallCounter
        (e.ResultCommands)
        (
          <MakeLinkChildAtermCommand
            e.ChildrenList s.CallCounter (/* Parents */)
          >
        )
        <FilterCommonVarsAndPatternCommands
          (e.PatternVars) (e.PatternCommands) e.UnusedVars
        >
      >;
}

FilterCommonVarsAndPatternCommands {
  /*
    Если в образце e-переменная имеет счётчик 1, значит, повторных
    e-переменных с этим индексом не было. Если эта переменная есть
    ещё и в списке unused, значит, она не используется.
  */
  (e.PatternVars-B (1 'e' e.Index) e.PatternVars-E)
  (
    e.PatternCommands-B
    (CmdClosedE s.Num 'e' e.Index)
    e.PatternCommands-E
  )
  (1 'e' e.Index) e.Unuseds =
    <FilterCommonVarsAndPatternCommands
      (e.PatternVars-B e.PatternVars-E)
      (
        e.PatternCommands-B
        (CmdComment 'Unused closed variable e.' e.Index)
        e.PatternCommands-E
      )
      e.Unuseds
    >;

  (e.PatternVars) (e.PatternCommands) t.OtherUnused e.Unuseds =
    <FilterCommonVarsAndPatternCommands
      (e.PatternVars) (e.PatternCommands) e.Unuseds
    >;

  (e.PatternVars) (e.PatternCommands) /* пусто */ =
    (e.PatternVars) e.PatternCommands;
}

ComposeSentenceCommands-Aux {
  s.NumRanges s.ResultCounter s.CallCounter (e.ResultCommands)
  (e.LinkAtermsCommands (e.Parents))
  (e.PatternVars) e.PatternCommands =
    <GenerateResult-OpenELoops
      <Map generator_MakeDeclaration e.PatternVars>
      (CmdRangeArray s.NumRanges)
      <MakeCmdResultCommand s.ResultCounter>
      <MakeCmdAtermArrayCommand s.CallCounter>
      <MakeCmdSaveParentAtermCommand s.CallCounter>
      (CmdInitB0)
      e.PatternCommands
      (CmdEmptyResult)
      e.ResultCommands
      e.LinkAtermsCommands
      (CmdSpliceFreelist)
      <MakeCmdZeroNewCalls s.CallCounter>
      <MakeEnqueueAtermsCommand e.Parents s.CallCounter>
      (CmdReturn)
    >;
}

$ENTRY generator_MakeDeclaration {
  (s.Usings s.Mode e.Index) =
    (CmdDeclareVar s.Usings s.Mode e.Index)
    <MakeDeclaration-Aux s.Usings s.Mode e.Index>;
}

MakeDeclaration-Aux {
  1 s.Mode e.Index = /* это была последняя */;

  s.Usings s.Mode e.Index =
    <generator_MakeDeclaration (<Dec s.Usings> s.Mode e.Index)>;
}

MakeCmdResultCommand {
  0 = /* пусто */;
  s.Counter = (CmdResultArray s.Counter);
}

MakeCmdAtermArrayCommand {
  0 = /* пусто */;
  1 = /* пусто */;
  s.CallCounter
    = (CmdAtermArray s.CallCounter)
      (CmdSaveReusedAterm);
}

MakeCmdSaveParentAtermCommand {
  0 = /* пусто */;
  1 = /* пусто */;
  s.CallCounter = (CmdSaveParentAterm);
}

MakeCmdZeroNewCalls {
  /* в конце необходимо переключиться на следующий А-терм,
   * если текущий не удалось переиспользовать и уменьшить
   счетчик дочерних в А-терме вызвавшей функции */
  0 = (CmdDecParentAtermCounter) (CmdAtermCategoryComplete);
  s.CallCounter = /* пусто */
}

GenerateResult-OpenELoops {
  e.Commands-B (CmdOpenedE s.BracketNum 'e' e.Index) e.Commands-E =
    e.Commands-B
    (CmdOpenedE-Start s.BracketNum 'e' e.Index)
    <GenerateResult-OpenELoops e.Commands-E>
    (CmdOpenedE-End s.BracketNum 'e' e.Index);

  e.Commands = e.Commands;
}
